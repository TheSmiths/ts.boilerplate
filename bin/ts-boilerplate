#!/usr/bin/env node

var gulp = require('gulp'),
    utils = require('gulp-util'),
    git = require('gulp-git'),
    _ = require('underscore'),
    pkginfo = require('pkginfo'),
    commander = require('commander'),
    prompt = require('prompt'),
    exec = require('child_process').exec,
    path = require('path'),
    fs = require('fs'),
    async = require('async');

pkginfo(module, 'name', 'version', 'description');
prompt.message = prompt.delimiter = "";

commander
    .version(module.exports.version)
    .description(module.exports.description);

/* ****** init command ****** */
var types = {1:'library', 2:'widget', 3:'module'},
    reTypes = new RegExp("^(" + _.flatten(_.pairs(types)).join('|') + ")$"),
    reName = /^[\w\.-]+$/;

commander
    .command('init')
    .description('Initialize a repository, test env and general structure for a component\'s dev.')
    .option('-t, --type [type]', 'Type of the component', reTypes)
    .option('-n, --name [name]', 'Name of the component', reName)
    .action(init)
    .on('--help', helpInit);

commander.parse(process.argv);

function handleError (err) {
    console.log(utils.colors.red("Error: " + (err.message || err)));
    process.exit(1);
}

function helpInit () {
    console.log("  Examples:"
    );
}

function init (env) {
    var options = {
            type: env.type,
            name: env.name},
        properties = {
            type: {
                message: utils.colors.white.bold("Select a type number or name:"),
                validator: reTypes,
                required: true},
            name: {
                message: utils.colors.white.bold("Component name:"),
                validator: reName,
                required: true}};

    prompt.start();

    var checkType = function (callback) {
        if (options.type !== undefined && options.type.match(reTypes)) { return callback(); }
        console.log(utils.colors.white.bold("What type of component would you like to create?\n")+
            _.map(types, function (type, key) {
                return "  " + key + ")  " + utils.colors.cyan(type);
            }).join('\n'));

        prompt.get(properties.type, function(err, result) {
            if (err) { callback(err); } 
            options.type = result.question;
            callback();
        });
    }; 

    var checkName = function (callback) {
        if (typeof options.name === "string" && options.name.match(reName)) { return callback(); }

        prompt.get(properties.name, function (err, result) {
            if (err) { callback(err) };
            options.name = result.question;
            callback();
        });
    }

    async.series([checkType, checkName], function (err) { 
        if (err) { return handleError(err); }
        proceedInit(options); 
    });
}

function proceedInit(options) {
    /* Ensure there is no repo */
    if (fs.readdirSync(process.cwd()).length > 0) { 
        return handleError("Not a valid init folder; Please, select an empty folder."); 
    }

    options.type =  types.hasOwnProperty(options.type) && types[options.type] || options.type;
    options.root = path.join(__dirname, '..');
    options.processRoot = process.cwd();

    var tasks = {
        testBranch: require('./tasks/testBranch.js')(options),
        project: require('./tasks/project.js')(options)
    };

    switch (options.type) {
        case 'library':
        case 'widget':
            options.projectDir = path.join(process.cwd(), 'test', options.name + "-test");
            options.projectName = options.name + "-test";
            options.projectRoot = path.join(process.cwd(), 'test');
            options.projectId = 'test.' + options.name;

            async.series(
                [
                    git.init,
                    tasks.testBranch.create,
                    tasks.project.populate,
                    tasks.testBranch.commit,
                ], function (err) {
                    if (err) { return handleError(err); }
                    console.log("Ok done.");
                }
            );
            break;
        default: handleError("Module not implemented yet. Sorry :/");
    }
}
