#!/usr/bin/env node

var gulp = require('gulp'),
    utils = require('gulp-util'),
    git = require('gulp-git'),
    _ = require('underscore'),
    pkginfo = require('pkginfo'),
    commander = require('commander'),
    prompt = require('prompt'),
    exec = require('child_process').exec,
    path = require('path'),
    fs = require('fs'),
    async = require('async');

pkginfo(module, 'name', 'version', 'description');
prompt.message = prompt.delimiter = "";

commander
    .version(module.exports.version)
    .description(module.exports.description);

/* ****** init command ****** */
var types = {1:'library', 2:'widget', 3:'module'},
    reTypes = new RegExp("^(" + _.flatten(_.pairs(types)).join('|') + ")$"),
    reName = /^[\w\.-]+$/;

commander
    .command('init')
    .description('Initialize a repository, test env and general structure for a component\'s dev.')
    .option('-t, --type [type]', 'Type of the component', reTypes)
    .option('-n, --name [name]', 'Name of the component', reName)
    .action(init)
    .on('--help', helpInit);

commander.parse(process.argv);

function handleError (err) {
    console.log(utils.colors.red("Error: " + (err.message || err)));
    process.exit(1);
}

function helpInit () {
    console.log("  Examples:"
    );
}

function init (env) {
    var options = {
            type: env.type,
            name: env.name},
        properties = {
            type: {
                message: utils.colors.white.bold("Select a type number or name:"),
                validator: reTypes,
                required: true},
            name: {
                message: utils.colors.white.bold("Component name:"),
                validator: reName,
                required: true}};

    prompt.start();

    var checkType = function (callback) {
        if (options.type !== undefined && options.type.match(reTypes)) { return callback(); }
        console.log(utils.colors.white.bold("What type of component would you like to create?\n")+
            _.map(types, function (type, key) {
                return "  " + key + ")  " + utils.colors.cyan(type);
            }).join('\n'));

        prompt.get(properties.type, function(err, result) {
            if (err) { callback(err); } 
            options.type = result.question;
            callback();
        });
    }; 

    var checkName = function (callback) {
        if (typeof options.name === "string" && options.name.match(reName)) { return callback(); }

        prompt.get(properties.name, function (err, result) {
            if (err) { callback(err) };
            options.name = result.question;
            callback();
        });
    }

    async.series([checkType, checkName], function (err) { 
        if (err) { return handleError(err); }
        proceedInit(options); 
    });
}

function proceedInit(options) {
    options.type =  types.hasOwnProperty(options.type) && types[options.type] || options.type;
   
    /* Ensure there is no repo */
    if (fs.readdirSync(process.cwd()).length > 0) { 
        return handleError("Not a valid init folder; Please, select an empty folder."); 
    }

    /* TODO modules not ready */
    if (options.type === 'module') { 
        return handleError("Module not implemented yet. Sorry :/");
    }

    /* Initialize the repo */
    var initRepo = git.init;        

    /* Create a test branch */
    var createTestBranch = function (callback) {
        git.checkout('test', {args: '-b'}, function (err) {
            if (err) { return callback(err); }
            var ticreateOptions = [
                    "-t app",
                    "-n " + options.name + "-test",
                    "-p all",
                    "-d " + path.join(process.cwd(), 'test'),
                    "--id test." + options.name,
                    "--no-prompt",
                    "--log-level warn"],
                alloynewOptions = [
                    "-l ERROR",
                    path.join(process.cwd(), 'test', options.name + "-test")];

            /* Create a test app */
            utils.log("Creating Titanium & Alloy test project");
            exec("mkdir test && ti create " + ticreateOptions.join(" "), function () {
                exec("alloy new " + alloynewOptions.join(" "), function (err) {
                    if (err) { return callback(err); }
                    
                    /* Dir from and to which we copy templates*/
                    var cpDirs = {
                        projectDir: alloynewOptions[1],
                        specDir: path.join(__dirname, '..', 'spec'),
                        gulpDir: path.join(__dirname, '..', 'task_runner', 'test', '.gulp'),
                        gulpTest: path.join(__dirname, '..', 'task_runner', 'test', 'gulpfile.js'),
                        gulpfile: path.join(__dirname, '..', 'task_runner', options.type, 'gulpfile.js'),
                        packagejson: path.join(__dirname, '..', 'dependencies', 'package.json'),
                    };
                    async.parallel([
                        function (done) {
                            /* Prepare a lib folder */
                            exec("mkdir " + path.join(cpDirs.projectDir, 'app', 'lib'), function () {
                                exec("mkdir " + path.join(cpDirs.projectDir, 'app', 'widgets'), done);
                            });
                        },
                        function (done) {
                            /* Copy initial template for spec */
                            utils.log("Adding a 'spec' folder to the app. #JasmineWithTiShadow");
                            exec("cp -r " + cpDirs.specDir + " " + cpDirs.projectDir, done);
                        },
                        function (done) {
                            /* Copy all task runner stuff */
                            utils.log("Adding task runner to the test app. #Gulp");
                            exec("cp " + cpDirs.gulpfile + " " + process.cwd());
                            exec("cp " + cpDirs.gulpTest + " " + cpDirs.projectDir);
                            exec("cp -r " + cpDirs.gulpDir + " " + cpDirs.projectDir, done);
                        }, function (done) {
                            /* Copy package.json to handle task runner dependencies */
                            utils.log("Copying package.json to handle task runner dependencies");
                            exec("cp " + cpDirs.packagejson + " " + cpDirs.projectDir, done);
                        }], function (err) {
                            if (err) { return callback(err); }
                            /* Install dependencies */
                            utils.log("Install dependencies");
                            exec("npm install gulp", function (err) {
                                if (err) { return callback(err); }

                                process.chdir(cpDirs.projectDir);
                                exec("npm install", function(err) {
                                    process.chdir(path.join('..', '..'));
                                    callback(err);
                                });
                            });
                        }
                    );
                });
            });
        });
    };

    async.series(
        [   
            initRepo,
            createTestBranch,
            commitTestBranch,
        ],function (err) {
          if (err) { return handleError(err); }
          console.log("Ok done.");
        }
    );
}
